#jinja2: lstrip_blocks: "True"
{% set NETWORK_INSTANCE = namespace(found = false) %}
{% set DCGW_SERVICEID_OFFSET = hostvars[inventory_hostname]['dcgw_serviceid_offset'] | default(0) | int %}
{% set DCGW_BHVPLS_OFFSET = hostvars[inventory_hostname]['dcgw_bhvpls_offset'] | default(10000) | int %}
{% for ni, prop in network_instance.items() %}
  {% if prop._state|default('present') != 'deleted' %}
    {% if ni == "default" %}
      {% set NETWORK_INSTANCE.found = true %}
- path: /router[router-name=Base]
  operation: update
  value:
    router-id: {{ prop['router-id'] }} 
      {% if prop['autonomous-system'] is defined %}
    autonomous-system: "{{ prop['autonomous-system'] | string }}"
      {% endif %}
      {% if prop.interfaces is defined and prop.interfaces is not none %}
    interface:
        {% for itf in prop.interfaces %} 
          {% set PORT = itf | ansible.builtin.regex_replace('^(.*)\\.\\d+$', '\\1') %}
          {% if itf is ansible.builtin.regex('^system0') %}
      - interface-name: system
          {% else %}
      - interface-name: I{{ PORT }}
        port: {{ PORT }}:0
          {% endif %}
        admin-state: enable
          {% if subinterface[itf].ipv4_address is defined %}
        ipv4:
          primary:
            address: {{ subinterface[itf].ipv4_address | ansible.utils.ipv4('address') | string }}
            prefix-length: "{{ subinterface[itf].ipv4_address | ansible.utils.ipv4('prefix') | string }}"
          {% endif %}
          {% if subinterface[itf].ipv6 is defined %}
        ipv6:
          forward-ipv4-packets: "true"
          {% endif %}
        {% endfor %}
      {% endif %}
      {% if prop.protocols is defined and prop.protocols is not none %}
        {% if prop.protocols.bgp is defined %}
    bgp:
      admin-state: enable
      min-route-advertisement: "1"
      rapid-withdrawal: "true"
      peer-ip-tracking: "true"
      split-horizon: "true"
      ebgp-default-reject-policy:
        import: "false"
      rapid-update:
        evpn: "true"
      group:
          {% for group, group_spec in prop.protocols.bgp.group.items() %}
      - group-name: {{ group }}
        admin-state: enable
        description: {{ group_spec.description|default('no description') }}
            {% if group_spec.peer_as is defined %}
        peer-as: "{{ group_spec.peer_as }}"
            {% endif %}
            {% if group_spec.local_as is defined %}
        local-as:
          as-number: "{{ group_spec.local_as }}"
          prepend-global-as: "false"
            {% endif %}
            {% if group_spec.export_policy is defined %}
        export:
          policy: {{ group_spec.export_policy }}
            {% endif %}
            {% if group_spec.import_policy is defined %}
        import:
          policy: {{ group_spec.import_policy }}
            {% endif %}
            {% if group_spec.local_address is defined %}
        local-address: {{ group_spec.local_address }}
            {% endif %}
        family:
            {% if group_spec.ipv4 is defined %}
              {% if group_spec.ipv4.admin_state | default('disable') == 'enable' %}
          ipv4: "true"
              {% endif %}
            {% endif %}
            {% if group_spec.evpn is defined %}
              {% if group_spec.evpn.admin_state | default('disable') == 'enable' %}
          evpn: "true"
              {% endif %}
            {% endif %}
            {% if prop.protocols.bgp.dynamic is defined %}
              {% set DYNAMIC = namespace(found=false) %}
              {% for nbr_itf, nbr_prop in prop.protocols.bgp.dynamic.interfaces.items() %}
                {% if nbr_prop["peer-group"] == group %}
                  {% set DYNAMIC.found = true %}
                {% endif %}
              {% endfor %}
              {% if DYNAMIC.found %}
        dynamic-neighbor:
          interface:
                {% for nbr_itf, nbr_prop in prop.protocols.bgp.dynamic.interfaces.items() %}
                  {% if nbr_prop["peer-group"] == group %}
                    {% set PORT = nbr_itf | ansible.builtin.regex_replace('^(.*)\\.\\d+$', '\\1') %}
            - interface-name: I{{ PORT }}
              allowed-peer-as:
                    {% for as in nbr_prop['allow-as'] %}
                - "{{as}}"
                    {% else %}
                []
                    {% endfor %}
                  {% endif %}
                {% endfor %}
              {% endif %}
            {% endif %}
          {% endfor %}
      neighbor:
          {% for nbr, nbr_spec in prop.protocols.bgp.neighbor.items() %}
        - ip-address: {{ nbr }}
          admin-state: enable
          group: {{ nbr_spec.peer_group }}
            {% if nbr_spec.peer_as is defined %}
          peer-as: "{{ nbr_spec.peer_as }}"
            {% endif %}
          {% else %}
          []
          {% endfor %}
        {% endif %}
        {% if prop.protocols.ospf is defined %}
    ospf:
          {% for instance, instance_spec in prop.protocols.ospf.items() %}
      - ospf-instance: "{{ loop.index0 | string }}"
        admin-state: enable
        export-policy: {{ instance_spec.export_policy }}
        area:
            {% for area, area_spec in instance_spec.area.items() %}
        - area-id: {{ area }}
          interface:
              {% for iface, iface_spec in area_spec.interfaces.items() %}
                {% set PORT = iface | ansible.builtin.regex_replace('^(.*)\\.\\d+$', '\\1') %}
                {% if iface is ansible.builtin.regex('^system0') %}
          - interface-name: system
                {% else %}
          - interface-name: I{{ PORT }}
                {% endif %}
                {% if iface_spec['interface-type'] is defined %}
            interface-type: {{ iface_spec['interface-type'] }}
                {% endif %}
                {% if iface_spec.passive is defined and iface_spec.passive %}
            passive: "true"
                {% endif %}
              {% else %}
          []
              {% endfor %}
            {% else %}
        []
            {% endfor %}
          {% else %}
      []
          {% endfor %}
        {% endif %}
      {% endif %}
    {% else %}
      {% if prop.type == 'ip-vrf' %}
        {% set NETWORK_INSTANCE.found = true %}
- path: /service/vprn[service-name={{ ni }}]
  operation: replace
  value:
    admin-state: enable
    customer: "1"
    description: "{{ DCGW_SERVICEID_OFFSET }}"
    service-id: "{{ DCGW_SERVICEID_OFFSET + prop.id }}"
    interface:
      interface-name: bhvpls
      admin-state: enable
      vpls:
        vpls-name: {{ ni }}-bhvpls
        evpn-tunnel: ""
- path: /service/vpls[service-name={{ ni }}-bhvpls]
  operation: replace
  value:
    admin-state: enable
    customer: "1"
    service-id: "{{ DCGW_BHVPLS_OFFSET + DCGW_SERVICEID_OFFSET + prop.id }}"
    routed-vpls:
      vxlan-ipv4-tep-ecmp: "true"
        {% if 'bgp_vpn' in prop.protocols %}
    bgp:
      bgp-instance: "1"
      route-target:
        export: "target:{{ prop.protocols.bgp_vpn.export_rt }}"
        import: "target:{{ prop.protocols.bgp_vpn.import_rt }}"
        {% endif %}
        {% if 'bgp_evpn' in prop.protocols %}
        {% set vxlan_instance = prop.protocols.bgp_evpn.vxlan_interface | ansible.builtin.regex_replace('^vxlan(\\d+)\\.\\d+$', '\\1') %}
        {% set tunnel_instance = prop.protocols.bgp_evpn.vxlan_interface | ansible.builtin.regex_replace('^(vxlan\\d+)\\.\\d+$', '\\1') %}
        {% set tunnel_instance_id = prop.protocols.bgp_evpn.vxlan_interface | ansible.builtin.regex_replace('^vxlan\\d+\\.(\\d+)$', '\\1') | int %}
    vxlan:
      instance:
        vxlan-instance: "{{ vxlan_instance }}"
        vni: "{{ tunnel_interface[tunnel_instance][tunnel_instance_id].ingress_vni }}"
    bgp-evpn:
      evi: "{{ prop.protocols.bgp_evpn.evi }}"
      routes:
        ip-prefix:
           advertise: "true"
      vxlan:
        bgp-instance: "1"
        admin-state: enable
        vxlan-instance: "{{ vxlan_instance }}"
        {% endif %}
      {% endif %}
    {% endif %}
  {% endif %}
{% endfor %}
{% if not NETWORK_INSTANCE.found %}
[]
{% endif %}
