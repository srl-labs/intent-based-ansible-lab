#jinja2: lstrip_blocks: "True"
{% for host in [query('inventory_hostnames', 'leaf'), query('inventory_hostnames', 'spine'), query('inventory_hostnames', 'borderleaf'), query('inventory_hostnames', 'superspine'), query('inventory_hostnames', 'dcgw')] | flatten %}
{% set overlay_asn=lookup('netbox.netbox.nb_lookup', 'locations', api_filter='slug=' + (hostvars[host].locations | first), api_endpoint=netbox_url, token=netbox_token).value.custom_fields.Overlay_ASN.asn %}
{{ host }}:
  bfd:
    interfaces:
  {% for itf in (hostvars[host].interfaces | selectattr('tags', 'contains', 'isl')) + (hostvars[host].interfaces | selectattr('name', 'eq', 'system0')) %}
      {{ itf.name }}.0:
        admin_state: enable
        desired_min_tx_interval: 100000
        detection_multiplier: 3
        required_min_rx_interval: 100000
  {% endfor %}

  network_instance:
    default:
      autonomous-system: {{ hostvars[host].custom_fields.ASN.asn }}
      router-id: {{ ((hostvars[host].interfaces | selectattr('name', 'eq', 'system0') | first).ip_addresses | first).address | split("/") | first }}
      interfaces:
      - system0.0
  {% for item in hostvars[host].interfaces | selectattr('tags', 'contains', 'isl') %}
      - {{ item.name }}.0
  {% endfor %}
      protocols:
        bgp:
          group:
            overlay:
  {% if 'spine' in hostvars[host].group_names %}
              cluster_id: {{ ((hostvars[host].interfaces | selectattr('name', 'eq', 'system0') | first).ip_addresses | first).address | split("/") | first }}
  {% endif %}
              evpn:
                admin_state: enable
              ipv4:
                admin_state: disable
              local_address: {{ ((hostvars[host].interfaces | selectattr('name', 'eq', 'system0') | first).ip_addresses | first).address | split("/") | first }}
              enable_bfd: true
              fast_failover: true
              local_as: {{ overlay_asn }}
              peer_as: {{ overlay_asn }}
  {% if 'leaf' in hostvars[host].group_names %}
            spines:
              description: Peer-group for spine neighbors
              epvn:
                admin_state: disable
              ipv4:
                admin_state: enable
              enable_bfd: true
              fast_failover: true
              peer_as: {{ (hostvars.values() | list | selectattr('group_names', 'contains', 'spine') | first).custom_fields.ASN.asn }}
  {% elif 'spine' in hostvars[host].group_names %}
            leafs:
              description: Peer-group for leaf neighbors
              epvn:
                admin_state: disable
              ipv4:
                admin_state: enable
              enable_bfd: true
              fast_failover: true
            dcgws:
              description: Peer-group for dcgw neighbors
              ipv4:
                admin_state: enable
              evpn:
                admin_state: disable
              enable_bfd: true
              fast_failover: true
  {% elif 'dcgw' in hostvars[host].group_names %}
            spines:
              description: Peer-group for spine neighbors
              epvn:
                admin_state: disable
              ipv4:
                admin_state: enable
              enable_bfd: true
              fast_failover: true
              local_as: {{ (hostvars[host]).custom_fields.ASN.asn }}
              peer_as: {{ (hostvars.values() | list | selectattr('group_names', 'contains', 'spine') | first).custom_fields.ASN.asn }}
  {% endif %}
          ipv4:
            admin_state: enable
            multipath: 2
          neighbor:
  {% if 'leaf' in hostvars[host].group_names %}
    {% set overlay_peers=[query('inventory_hostnames', 'spine')] | flatten %}
  {% elif 'spine' in hostvars[host].group_names %}
    {% set overlay_peers=[query('inventory_hostnames', 'leaf'), query('inventory_hostnames', 'dcgw')] | flatten %}
  {% elif 'dcgw' in hostvars[host].group_names %}
    {% set overlay_peers=[query('inventory_hostnames', 'spine')] | flatten %}
  {% endif %}
  {% for item in overlay_peers %}
            {{ (((hostvars[item]).interfaces | selectattr('name', 'eq', 'system0') | first).ip_addresses | first).address | split("/") | first }}:
              peer_group: overlay
  {% endfor %}
  {% for item in hostvars[host].interfaces | selectattr('tags', 'contains', 'isl') if item.ip_addresses %}
    {% set peer_role=(hostvars[(item.link_peers | first).device.name]).device_roles | first %}
            {{ (item.ip_addresses | first).address | ansible.utils.ipaddr('peer') }}:
    {% if peer_role == 'spine' %}
              peer_group: spines
    {% elif peer_role == 'leaf' %}
              peer_group: leafs
              peer_as: {{ (hostvars[(item.link_peers | first).device.name]).custom_fields.ASN.asn }}
    {% elif peer_role == 'dcgw' %}
              peer_group: dcgws
              peer_as: {{ (hostvars[(item.link_peers | first).device.name]).custom_fields.ASN.asn }}
    {% endif %}
  {% endfor %}

  interfaces:
  {% for itf in hostvars[host].interfaces | selectattr('tags', 'contains', 'isl')  %}
    {{ itf.name }}:
      admin_state: {{ "enable" if itf.enabled else "disable" }}
      description: {{ itf.description if itf.description else "no description" }}
    {% if itf.mtu is not none %}
      mtu: {{ itf.mtu }}
    {% endif %}
    {% if itf.mode is not none and itf.mode.value is defined %}
      {% if itf.mode.value == 'tagged' %}
      vlan_tagging: true
      {% endif %}
    {% endif %}
  {% endfor %}
    system0:
      admin_state: enable
  {% if 'leaf' in hostvars[host].group_names %}
    irb1:
  {% endif %}

  subinterface:
  {% for itf in (hostvars[host].interfaces | selectattr('tags', 'contains', 'isl')) + (hostvars[host].interfaces | selectattr('name', 'eq', 'system0')) %}
    {{ itf.name }}.0:
    {% if itf.ip_addresses is not none and itf.ip_addresses|length > 0 %}
      ipv4_address: "{{ itf.ip_addresses[0].address }}"
    {% endif %}
    {% if itf.mtu is not none %}
      mtu: {{ itf.mtu }}
    {% endif %}
  {% endfor %}

  routing_policy:
    prefix_set:
      loopbacks:
        prefix:
        - ip-prefix: {{ hostvars.values() | map(attribute='interfaces') | flatten | selectattr('name', 'eq', 'system0') | map(attribute='ip_addresses') | flatten | map(attribute='address') | ansible.utils.cidr_merge('span') }}
          mask-length-range: "32..32"
{% endfor %}
